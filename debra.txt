// process local variables :
long pid; // process id
long checkNext; // the next process whose announcement should be checked
blockbag *bags[0..2]; // limbo bags for the last three epochs
blockbag *currentBag; // pointer to the limbo bag for the current epoch
long index; // index of currentBag in bags [0..2]
long opsSinceCheck; // # ops performed since checking another process â€™ announcement
// shared variables :
long epoch; // current epoch
long announce[n]; // per - process announced epoch and quiescent bit
objectpool *pool; // pointer to object pool

bool getQuiescentBit(long otherPid) { return announce[otherPid] & 1; }
void setQuiescentBitTrue(long otherPid) { announce[otherPid] = announce[otherPid] | 1; }
void setQuiescentBitFalse(long otherPid) { announce[otherPid] = announce[otherPid] & ~1; }
bool isEqual(long readEpoch, long announcement) {
    return readEpoch == (announcement & ~1); // compare read epoch to epoch - bits from announcement
}

void rotateAndReclaim() { // rotate limbo bags and reclaim records retired two epochs ago
    index = (index + 1) % 3; // compute index of oldest limbo bag
    currentBag = bags[index]; // reuse the oldest libmo bag as the new currentBag
    pool->moveFullBlocks(currentBag); // move all full blocks to the pool
}
void retire(record *p) { currentBag->add(p); }
bool isQuiescent() { return getQuiescentBit(pid); }
void enterQstate() { setQuiescentBitTrue(pid); }
bool leaveQstate() {
    bool result = false;
    long readEpoch = epoch;
    if (!isEqual(readEpoch, announce[pid])) { // our announcement differs from the current epoch
        opsSinceCheck = checkNext = 0; // we are now scanning announcements for a new epoch
        rotateAndReclaim();
        result = true; // result indicates that we changed our announcement
    }
    // incrementally scan all announcements
    if (++opsSinceCheck >= CHECK_THRESH) {
        opsSinceCheck = 0;
        long other = checkNext % n;
        if (isEqual(readEpoch, announce[other]) || getQuiescentBit(other)) {
            long c = ++checkNext;
            if (c >= n && c >= INCR_THRESH) { // if we scanned every announcement
                CAS(&epoch, readEpoch, readEpoch + 2);
            }
        }
    }
    announce[pid] = readEpoch; // announce new epoch with quiescent bit = false
    return result;
}
